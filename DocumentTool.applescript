-- DocumentTool for InDesign-- version 1.0 beta-- created by medul6, Michael Heck, 2014-- NOT open sourced YET on September 7th, 2012 on Github > check the LICENSE.txt and README.md in the repository for detailed information-- https://github.com/medul6/...-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••-- global variablesglobal activeDocumentglobal openDocumentsglobal otherDocuments--global activeWindow--global pdfPresetsOnComputer--global preservedPageRangeglobal stopBoolglobal splittedRange--global pageNumberInsertionpoint--global inputRangeglobal splittedMagic--global splittedRangeReverseglobal splittedRangeMagic--global splittedRangeMagicLoop--global incrementValue--global repeatNumber--global textOverflows--test variables!!!--global xxx--global filePath--global chosenPresetText--global docName--global newFilePath--global pathItems--global pageRange--global newdocName--global failedLinks--global textOverflows--global modifiedLinks--global missingLinks--global exportPreset--properties!property functionChoice : {""}--property chosenPreset : {"sk-Screen"}--property pageRange : "all pages"-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••tell application id "com.adobe.InDesign"		set stopBool to false	-- set up some informations from the current state as variables	set activeDocument to active document	set activeWindow to active window	set openDocuments to every document	set otherDocuments to every document whose id is not activeDocument's id	-- only pdf presets are captured that are not build in. we have our own! remove the whose clause to show all of them, or modify the whose clause to show only them.	--set pdfPresetsOnComputer to name of every PDF export preset whose name does not contain "["		-- initialize some lists (to be filled in the next two repeat loops)	--set splittedMagic to {}			--my linkCheck()	--my textOverflowCheck()	my pageCountCheck()		my functionChooser()			if stopBool is true then		displayTheEnd() of me	end if	end tell-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on functionChooser()	set functionChoice to choose from list {"Alle Kapitelanfänge löschen", "Seiten löschen ...", "Seiten einfügen ...", "Seiten verschieben ..."} default items functionChoice with prompt "Funktion wählen:" OK button name "Weiter!"		if the functionChoice = {"Alle Kapitelanfänge löschen"} then		deleteEverySection() of me	else if the functionChoice = {"Seiten löschen ..."} then		deletePages() of me	else if the functionChoice = {"Seiten einfügen ..."} then		insertPages() of me	else if the functionChoice = {"Seiten verschieben ..."} then		movePages() of me			end if	end functionChooser-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on pageCountCheck()	tell application id "com.adobe.InDesign"				set pageCountBool to true		set pageCount to count pages of activeDocument		set pageCountRepeat to pageCount				repeat with x from 1 to count otherDocuments			set pageCountRepeat to count pages of otherDocuments's item x			if pageCountRepeat is not equal to pageCount then				set pageCountBool to false			end if			if pageCountBool is false then				display dialog "Dokumente benötigen die gleiche Seitenanzahl! " & return & "-----------------------------------------" & return & ((name of otherDocuments's item x) as string) & return & "-----------------------------------------" & return & "hat eine unterschiedliche Seitenanzahl!" buttons "OK" default button "OK"			end if		end repeat	end tellend pageCountCheck-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on deleteEverySection()	tell application id "com.adobe.InDesign"		repeat with x from 1 to count openDocuments -- this iterates through all open documents						set sectionsOfActiveDocument to every section of openDocuments's item x						repeat with y from 2 to count sectionsOfActiveDocument				delete item y of sectionsOfActiveDocument			end repeat					end repeat			end tell	set stopBool to trueend deleteEverySection-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on deletePages()	tell application id "com.adobe.InDesign"				set buttonName to functionChoice & " !" as string				display dialog "Welche Seiten sollen gelöscht werden?" & return & "Seiten müssen nicht zusammenhängen, z.B. '2-3,8-19'" & return & "Aber Reihenfolge einhalten(!): '2-3,8-19' nicht '8-19,2-3'" default answer "" buttons {"Abbrechen!", (buttonName as string)} default button (buttonName as string)		if button returned of result is "Abbrechen!" then			return		else			set inputRange to (text returned of result)		end if				my inputRangeSplitter(inputRange)				my MagicSplitter(splittedRange)						--set splittedRangeReverse to reverse of splittedRange		set splittedRangeReverse to reverse of splittedMagic				repeat with x from 1 to count openDocuments -- this iterates through all open documents			repeat with y from 1 to count splittedRangeReverse -- this iterates through all pages				delete page (splittedRangeReverse's item y) of openDocuments's item x			end repeat		end repeat			end tell	set stopBool to trueend deletePages-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on insertPages()	tell application id "com.adobe.InDesign"				set buttonName to functionChoice & " !" as string				display dialog "Wieviele Seiten sollen eingefügt werden?" & return & "NUR ganze Zahlen, gerade oder ungerade! z.B. '2' oder '7'" default answer "" buttons {"Abbrechen!", (buttonName as string)} default button (buttonName as string)		if button returned of result is "Abbrechen!" then			return		else			set numerOfPagesToInsert to (text returned of result)		end if								if numerOfPagesToInsert contains "," then			display dialog "NUR ganze Zahlen!!!" buttons {"Hab's verstanden!"} default button "Hab's verstanden!"			return		else if numerOfPagesToInsert contains "-" then			display dialog "NUR ganze Zahlen!!!" buttons {"Hab's verstanden!"} default button "Hab's verstanden!"			return		end if						display dialog "Nach welcher Seite sollen die Seiten eingefügt werden?" & return & "NUR ganze Zahlen, keine Bereiche!" default answer "" buttons {"Abbrechen!", (buttonName as string)} default button (buttonName as string)		if button returned of result is "Abbrechen!" then			return		else			set pageNumberInsertionpoint to (text returned of result)		end if						if pageNumberInsertionpoint contains "," then			display dialog "NUR ganze Zahlen!!!" buttons {"Hab's verstanden!"} default button "Hab's verstanden!"			return		else if pageNumberInsertionpoint contains "-" then			display dialog "NUR ganze Zahlen!!!" buttons {"Hab's verstanden!"} default button "Hab's verstanden!"			return		end if						repeat with x from 1 to count openDocuments -- this iterates through all open documents			repeat with y from 1 to (numerOfPagesToInsert as integer)				make page at after page pageNumberInsertionpoint of openDocuments's item x			end repeat		end repeat			end tell	set stopBool to trueend insertPages-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on movePages()	tell application id "com.adobe.InDesign"				set buttonName to functionChoice & " !" as string				display dialog "Welche Seiten sollen verschoben werden?" & return & "Immer nur zusammenhängende Druckbögen!" & return & "Mit Divis oder Kommagetrennt! z.B. '4-5' oder '4,5'" & return & "Es können auch mehrere Bögen sein! z.B. '4-9' oder '12-23'" default answer "" buttons {"Abbrechen!", (buttonName as string)} default button (buttonName as string)		if button returned of result is "Abbrechen!" then			return		else			set inputRange to (text returned of result)		end if				--if inputRange contains "" then		--	return		--end if				if inputRange contains "," then			my inputRangeSplitter(inputRange)		else if inputRange contains "-" then			my inputRangeSplitterFromTo(inputRange)		end if				--my inputRangeSplitter(inputRange)				display dialog "Nach welcher Seite sollen die Seiten verschoben werden?" & return & "NUR ganze Zahlen, keine Bereiche!" default answer "" buttons {"Abbrechen!", (buttonName as string)} default button (buttonName as string)		if button returned of result is "Abbrechen!" then			return		else			set pageNumberInsertionpoint to (text returned of result)		end if				if inputRange contains pageNumberInsertionpoint then			return		end if						--set splittedRangeReverse to reverse of splittedRange		if (count splittedRange) > "2" then			display dialog "Immer Doppelseite für Doppelseite verschieben!" & return & "Es wurden mehr als zwei Seiten angegeben!"			set splittedRange to {"", ""}		else if (count splittedRange) < "2" then			display dialog "Immer Doppelseite für Doppelseite verschieben!" & return & "Es wurde nur eine Seite angegeben!"			set splittedRange to {"", ""}		end if				repeat with x from 1 to count openDocuments -- this iterates through all open documents			--repeat with y from 1 to count splittedRange -- this iterates through all pages			--delete page (splittedRange's item y) of openDocuments's item x			tell openDocuments's item x				move (pages (splittedRange's item 1 as integer) thru (splittedRange's item 2 as integer)) to after (page (pageNumberInsertionpoint as integer))			end tell			--end repeat		end repeat				--tell the active document		--	move (pages 2 thru 3) to before page 1		--end tell							end tell	set stopBool to trueend movePages-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on inputRangeSplitter(inputRange)	set oldDelimiters to AppleScript's text item delimiters -- always preserve original delimiters	set AppleScript's text item delimiters to {","}	set splittedRange to text items of inputRange	set AppleScript's text item delimiters to oldDelimiters -- always restore original delimiters	return splittedRangeend inputRangeSplitter-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on inputRangeSplitterFromToMagic(inputRange)	set oldDelimiters to AppleScript's text item delimiters -- always preserve original delimiters	set AppleScript's text item delimiters to {"-"}		set splittedRangeMagic to text items of inputRange		if (splittedRangeMagic's item 2 as integer) is not ((splittedRangeMagic's item 1 as integer) + 1) then		set incrementValue to (splittedRangeMagic's item 1 as integer) + 1		set splittedRangeMagicLoop to {(splittedRangeMagic's item 1 as integer)}				--repeat with x from (splittedRangeMagic's item 1 as integer) to (splittedRangeMagic's item 2 as integer) -- this iterates through		--	set splittedRangeMagicLoop to splittedRangeMagicLoop & (incrementValue + 1)		--end repeat				set repeatNumber to (splittedRangeMagic's item 2 as integer) - (splittedRangeMagic's item 1 as integer)		repeat repeatNumber times -- this iterates through			set splittedRangeMagicLoop to splittedRangeMagicLoop & incrementValue			set incrementValue to incrementValue + 1		end repeat						set splittedRangeMagic to splittedRangeMagicLoop	end if		set AppleScript's text item delimiters to oldDelimiters -- always restore original delimiters	return splittedRangeMagicend inputRangeSplitterFromToMagic-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on inputRangeSplitterFromTo(inputRange)	set oldDelimiters to AppleScript's text item delimiters -- always preserve original delimiters	set AppleScript's text item delimiters to {"-"}	set splittedRange to text items of inputRange	set AppleScript's text item delimiters to oldDelimiters -- always restore original delimiters	return splittedRangeend inputRangeSplitterFromTo-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on MagicSplitter(splittedRange)	set oldDelimiters to AppleScript's text item delimiters -- always preserve original delimiters		set AppleScript's text item delimiters to {"-"}	set splittedMagic to {}		--set splittedMagic to text items of splittedRange		repeat with x from 1 to count splittedRange -- this iterates through		if splittedRange's item x does not contain "-" then			set splittedMagic to splittedMagic & splittedRange's item x			--set splittedRange's item x to end of splittedMagic		else if splittedRange's item x contains "-" then			inputRangeSplitterFromToMagic(splittedRange's item x)			--set xxx to splittedRange			set splittedMagic to splittedMagic & splittedRangeMagic's items			--set splittedRange's items to end of splittedMagic		end if			end repeat							set AppleScript's text item delimiters to oldDelimiters -- always restore original delimiters	return splittedMagicend MagicSplitter-- •••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••on displayTheEnd()	--display dialog "Fertig!" buttons "OK" default button "OK" giving up after 1	say "OK!" using "Zarvox" --"Zarvox"end displayTheEnd